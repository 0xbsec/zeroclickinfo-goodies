{
    "id": "go-lang_script_cheat_sheet",
    "name": "Go Language Cheat Sheet",
    "description": "Golang help",
    "metadata": {
        "sourceName": "Go-lang Cheat Sheet",
        "sourceUrl": "https://github.com/a8m/go-lang-cheat-sheet"
    },
    "aliases": [
        "go, golang guide, go-lang, golang operators, golang functions"
    ],
    "template_type": "terminal",
    "section_order": [
        "Variables",
        "Operators and aliases",
        "Functions",
        "Built In Types",
        "Control Structures",
        "Arrays, Slices, Ranges",
        "Maps",
        "Structs",
        "Pointers",
        "Interfaces"
    ],
    "sections": {
        "Variables": [{
            "val": "Declare a variable",
            "key": "var varname vartype"
        }, {
            "val": "Declare a variable and assign a value",
            "key": "var varname vartype = value"            
        }, {    
            "val": "Declare a variable shorthand, only in func bodies, omit var keyword, type is always implicit",
            "key": "varname := value"            
        }, {    
            "val": "Declare a constant",
            "key": "const constant = value"            
        }],
        "Functions": [{
            "val": "A simple function",
            "key": "func functionName() \\{\\}"
        }, {
            "val": "Function with parameters (types go after identifiers)",
            "key": "func functionName(param1 string, param2 int) \\{\\}"
        }, {
            "val": "Multiple parameters of the same type",
            "key": "func functionName(param1, param2 int) \\{\\}"
        }, {
            "val": "Return type declaration",
            "key": "func functionName() int \\{ <br> &nbsp;&nbsp;&nbsp;&nbsp;return 42  <br>\\}"
        }, {
            "val": "Can return multiple values at once",
            "key": "func returnMulti() (int, string) \\{ <br>&nbsp;&nbsp;&nbsp;&nbsp;return 42, \"foobar\" <br>\\} <br> var x, str = returnMulti()"
        }, {
            "val": "Return multiple named results simply by return",
            "key": "func returnMulti2() (n int, s string) \\{ <br> &nbsp;&nbsp;&nbsp;&nbsp;n = 42 <br> &nbsp;&nbsp;&nbsp;&nbsp;s = \"foobar\" <br>  &nbsp;&nbsp;&nbsp;&nbsp;// n and s will be returned <br> &nbsp;&nbsp;&nbsp;&nbsp;return <br> \\} <br> var x, str = returnMulti2()"
        }],
        "Built In Types": [{
            "val": "",
            "key": "bool<br><br>string<br><br>int  int8  int16  int32  int64<br>uint uint8 uint16 uint32 uint64 uintptr<br><br>byte // alias for uint8<br><br>rune // alias for int32 ~= a character (Unicode code point)<br><br>float32 float64<br><br>complex64 complex128"
        }],
        "Control Structures": [{
            "val": "If",
            "key": "func main() \\{<br>&nbsp;&nbsp;&nbsp;&nbsp;if x > 0 \\{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return x<br>&nbsp;&nbsp;&nbsp;&nbsp;\\} else \\{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return -x<br>\\}"
        }, {
            "val": "Loops",
            "key": "There's only `for`, no `while`, no `until`<br><br> for i := 1; i < 10; i++ \\{<br>\\}<br><br>while - loop<br><br>for ; i < 10;  \\{<br>\\}<br><br>you can omit semicolons if there is only a condition<br><br>for i < 10  \\{<br>\\}<br><br>you can omit the condition ~ while (true)<br><br>for \\{<br>\\}"
        }, {
            "val": "Switch",
            "key": "switch operatingSystem \\{<br>case \"darwin\":<br>&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(\"Mac OS Hipster\")<br><br>// cases break automatically, no fallthrough by default<br><br>case \"linux\":<br>&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(\"Linux Geek\")<br>default:<br>&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(\"Other\")<br>\\}<br><br>// as with for and if, you can have an assignment statement before the switch value<br><br>switch os := runtime.GOOS; os \\{<br>case \"darwin\": ...<br>\\}"
        }],    
        "Arrays, Slices, Ranges": [{
            "key": "var a \\[10\\]int",
            "val": "Declare an int array with length 10. Array length is part of the type!"
        }, {
            "key": "a\\[3\\] = 42",
            "val": "set elements"
        }, {
            "key": "i := a\\[3\\]",
            "val": "Read elements"
        }, {
            "key": "var a = \\[2\\]int\\{1, 2\\}",
            "val": "Declare and initialize" 
        }, {
            "key": "a := \\[2\\]int\\{1, 2\\}",
            "val": "Shorthand"
        }, {
            "key": "a := \\[...\\]int\\{1, 2\\}",
            "val": "Elipsis -&gt; Compiler figures out array length"
        }, {
            "key": "var a \\[\\]int",
            "val": "Declare a slice - similar to an array, but length is unspecified"
        }, {
            "key": "var a = \\[\\]int \\{1, 2, 3, 4\\}",
            "val": "Declare and initialize a slice (backed by the array given implicitly)"
        }, {
            "key": "a := \\[\\]int\\{1, 2, 3, 4\\}",
            "val": "Shorthand"
        }, {
            "key":"chars := \\[\\]string\\{0:&quot;a&quot;, 2:&quot;c&quot;, 1: &quot;b&quot;\\}",
            "val": " \\[ \"a\", \"b\", \"c\" \\] "
        }, {
            "key": "var b = a\\[lo:hi\\]",
            "val": "Creates a slice (view of the array) from index lo to hi-1"
        }, {
            "key": "var b = a\\[1:4\\] ",
            "val": "Slice from index 1 to 3"
        }, {
            "key": "var b = a\\[:3\\]",
            "val": "Missing low index implies 0"
        }, {
            "key": "var b = a\\[3:\\]",
            "val": "Missing high index implies len(a)"
        }, {
            "key":"a = make(\\[\\]byte, 5, 5)",
            "val":"Create a slice with make, first arg length, second capacity"
        }, {
            "key":"a = make(\\[\\]byte, 5)",
            "val":"Create a slice with make, capacity is optional"
        }, {
            "key":"x := \\[3\\]string\\{&quot;applies&quot;,&quot;oranges&quot;,&quot;kiwis&quot;\\}",
            "val":"Create a slice from an array"
        }, {
            "key":"s := x\\[:\\]",
            "val":"A slice referencing the storage of x"
        }],
        "Maps": [{
            "key": "var m map\\[string\\]int<br>m = make(map\\[string\\]int)<br>m\\[\"key\"\\] = 42<br>fmt.Println(m\\[\"key\"\\])<br><br>delete(m, \"key\")<br>elem, ok := m\\[\"key\"\\]",
            "val": "Map syntax"
        }, {
            "key": "var m = map\\[string\\]Vertex\\{<br>&nbsp;&nbsp;&nbsp;&nbsp;\"Bell Labs\": \\{40.68433, -74.39967\\},<br>&nbsp;&nbsp;&nbsp;&nbsp;\"Google\": \\{37.42202, -122.08408\\},<br>\\}",
            "val": "Map literal"
        }],    
        "Structs": [{
            "key": "type Vertex struct \\{<br>&nbsp;&nbsp;&nbsp;&nbsp;X, Y int<br>\\}",
            "val": "Struct declaration"
        }, {
            "key": "var v = Vertex\\{1, 2\\}",
            "val":  "Creating"
        }, {
            "key": "var v = Vertex\\{X: 1, Y: 2\\}",
            "val": "Creates a struct by defining values with keys"
        }, {
            "key": "v.X = 4",
            "val": "Accessing members"
        }, {
            "key": "func (v Vertex) Abs() float64 \\{<br>&nbsp;&nbsp;&nbsp;&nbsp;return math.Sqrt(v.X*v.X + v.Y*v.Y)<br>\\}",
            "val": "You can declare methods on structs. The struct you want to declare the method on (the receiving type) comes between the the func keyword and the method name. The struct is copied on each method call."
        }, {
            "key": "v.Abs()",
            "val": "Call method"
        }, {
            "key": "func (v *Vertex) add(n float64) \\{<br>&nbsp;&nbsp;&nbsp;&nbsp;v.X += n<br>&nbsp;&nbsp;&nbsp;&nbsp;v.Y += n<br>\\}",
            "val": "For mutating methods, you need to use a pointer (see below) to the Struct as the type. With this, the struct value is not copied for the method call."
        }, {
            "key": "point := struct \\{<br>&nbsp;&nbsp;&nbsp;&nbsp;X, Y int<br>\\}\\{1, 2\\}",
            "val": "Anonymous structs"
        }],   
        "Pointers": [{
            "key": "p := Vertex\\{1, 2\\}",
            "val": "p is a Vertex"
        }, {
            "key": "q := &p",
            "val": "q is a pointer to a Vertex"
        }, {
            "key": "r := &Vertex\\{1, 2\\}",
            "val": "r is a pointer to a Vertex"
        }, {
            "key": "var s *Vertex = new(Vertex)",
            "val": "new creates a pointer to a new struct instance"
        }],    
        "Interfaces": [{
            "key": "type Awesomizer interface \\{<br>&nbsp;&nbsp;&nbsp;&nbsp;Awesomize() string<br>\\}",
            "val": "Interface declaration"
        }, {
            "key":"type Foo struct \\{\\}",
            "val": "Types do *not* declare to implement interfaces"
        }, {
            "key": "func (foo Foo) Awesomize() string \\{<br>&nbsp;&nbsp;&nbsp;&nbsp;return \"Awesome!\"<br>\\}",
            "val": "Rather, types implicitly satisfy an interface if they implement all required methods"
        }],    
        "Operators and aliases": [{
            "key": "+",
            "val":"Addition" 
        }, {
            "key": "-",
            "val":"Subtraction" 
        }, {
            "key": "*",
            "val":"Multiplication" 
        }, {
            "key": "/",
            "val":"Quotient" 
        }, {
            "key": "%",
            "val":"Remainder" 
        }, {
            "key": "&amp;",
            "val":"Bitwise and" 
        }, {
            "key": "|",
            "val":"Bitwise or" 
        }, {
            "key": "^",
            "val":"Bitwise xor"
        }, {
            "key": "&amp;^",
            "val":"Bit clear (and not)" 
        }, {
            "key": "&lt;&lt;",
            "val":"Left shift" 
        }, {
            "key": "&gt;&gt;",
            "val":"Right shift" 
        }, {
            "key": "==",
            "val":"Equal" 
        }, {
            "key": "!=",
            "val":"Not equal" 
        }, {
            "key": "&lt;",
            "val":"Less than" 
        }, {
            "key": "&lt;=",
            "val":"Less than or equal" 
        }, {
            "key": "&gt;",
            "val":"Greater than" 
        }, {
            "key": "&gt;=",
            "val":"Greater than or equal" 
        }, {
            "key": "&amp;&amp;",
            "val":"Logical and" 
        }, {
            "key": "||",
            "val":"Logical or" 
        }, {
            "key": "!",
            "val":"Logical not"
        },  {
            "key": "&amp;",
            "val":"Address of / create pointer" 
        }, {
            "key": "*",
            "val":"Dereference pointer" 
        }, {
            "key": "&lt;-",
            "val":"Send / receive operator" 
        } ]
    }
}